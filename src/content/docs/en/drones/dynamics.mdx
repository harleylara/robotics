---
title: Multicopter Dynamics
description: System modeling and identification
---

## Outline

- Frames
    - inertial frame (global frame fixed to the "world")
    - body frame: center of mass and local reference for sensors and actuators
- Rigid body motion
    - Rotations
    - translation
- Modeling
- Scaling laws. @kumarOpportunitiesChallengesAutonomous2017

Some references for simulation generals:
- @muraleedharanModellingSimulationUAV2020

## 3D Space and Frames

<Think>
    How would you represent a 3D space? What are the properties of it?
</Think>

See the note in [Euclidean Space](geometry/euclidean)

## Rigid Body Motion SE(3)


Some resources like Wikipedia define **rigid body motion** as a mapping $g_t(\vx) = \mR \vx + \vt$. But this section would provide more details that leads to the derivation of this transformation in terms of linear algebra.


### Orientation Representation

The orientation of the body frame with respect to the inertial frame is defined by the matrix $\mR$

$$
\mR : \fB \rightarrow \fI \quad \mR \in \SO(3)
$$

Velocity vector $\vv \in \fI$, with notation as $\prescript{}{\fI}{\vv}$: linear velocity in the inertial frame

$\Omega \in \fB$ is the angular velocity of the airframe expressed in body fixed frame

mass

inertial matrxix $\mI \in \R^{3 \times 3}$ around the center of mass: $\prescript{}{\fB}{\mI}$

## Modeling

based on: @hamelDynamicModellingConfiguration2002

- set the inertial frame
- position vector of the center of mass in the inertial frame

$$
\xi  = [\xi_1, \xi_2, \xi_3] \in \fI
$$

- set "body fixed frame" $\fB$
- rotation from inertial frame to fix body frame $\mR : \fB \rightarrow \fI \quad \mR \in \SO(3)$

## Allocation

Let rotor $i$ sit at body-frame position $\vr_i = (x_i, y_i, z_i)$ and push along the unit vector $\vn_i$ (usually $(0, 0, 1)$) if rotors are vertical. Let its thrust be:

$$
t_i = k_{T,i} \Omega^{2}_{i}
$$

and its reaction (drag) torque magnitude be

$$
q_i = k_{Q,i} \Omega^{2}_{i}
$$

acting along $\vn_i$ with sign $\sigma_i \in {+1, -1}$ depending in spin direction (choose $\sigma_i = +1$ for positive yaw torque by the right-hand rule, $-1$ otherwise).

Each rotor contributes force $\vf_i = T_i \vn_i$ and moment:

$$
\v{\tau}_i = \vr_i \times (t_i \vn_i) + \sigma_i q_i \vn_i
$$

The body control vector:

$$
\vw = 
\underbrace{
\begin{bmatrix}
k_{T,1}\,\vn_1 & \cdots & k_{T,n}\,\vn_n \\
k_{T,1}\!\left(\vr_1 \times \vn_1\right) + \sigma_1\,k_{Q,1}\,\vn_1
& \cdots &
k_{T,n}\!\left(\vr_n \times \vn_n\right) + \sigma_n\,k_{Q,n}\,\vn_n
\end{bmatrix}
}_{\mA_{6 \times n}}

\,\Omega^{2}\, .

$$

## Core Idea

1. Controllers output a desired thrust and body torques
2. Geometric relation

$$
\vw = \mA \mT
$$

3. Solve for $\mT$ using pseudoinverse or a constrained solver)

$$
\mT = \mA^{\dagger} \vw
$$

See [Control Allocation (Mixing) - PX4 Docs](https://docs.px4.io/main/en/concept/control_allocation). Related to parameter [`CA_METHOD`](https://docs.px4.io/main/en/advanced_config/parameter_reference#CA_METHOD)

4. Map thrust to PWM/DShot via thrust curve

5. Saturation handling & priorities


## References
